{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"<code>urn_citation</code>","text":"<p>A Python library for representing and manipulating CTS URNs (Canonical Text Services Uniform Resource Names) and CITE2 URNs.</p> <p>See reference documentation for full API details.</p>"},{"location":"cite2urn/","title":"Documentation for the <code>Cite2Urn</code> class","text":""},{"location":"cite2urn/#urn_citation.Cite2Urn","title":"<code>urn_citation.Cite2Urn</code>","text":"<p>               Bases: <code>Urn</code></p> <p>A class representing a CITE2URN, which is a specific type of URN used in the CITE architecture.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>class Cite2Urn(Urn):\n    \"\"\"\n    A class representing a CITE2URN, which is a specific type of URN used in the CITE architecture.\n    \"\"\"\n    namespace: str\n    collection: str\n    version: str | None = None\n    object_id: str | None = None\n\n    @model_validator(mode='after')\n    def validate_subreferences(self):\n        \"\"\"Validate subreferences in object identifier.\n\n        Ensures that:\n        - object_id component has at most one @ per range part\n        - subreferences are not empty\n\n        Raises:\n            ValueError: If the subreference constraints are violated.\n        \"\"\"\n        if self.object_id is not None:\n            range_parts = self.object_id.split(\"-\")\n            for part in range_parts:\n                if part.count(\"@\") &gt; 1:\n                    raise ValueError(f\"Each object component can have at most one @ delimiter for subreference, found {part.count('@')} in '{part}'\")\n                # Check for empty subreferences\n                if \"@\" in part:\n                    subref_parts = part.split(\"@\")\n                    if len(subref_parts) != 2 or not subref_parts[1]:\n                        raise ValueError(f\"Subreference cannot be empty, found empty subreference in '{part}'\")\n\n        return self\n\n    @classmethod\n    def from_string(cls, raw_string: str) -&gt; \"Cite2Urn\":\n        \"\"\"Parse a ``urn:cite2`` string into a ``Cite2Urn`` instance.\n\n        The string must be in the form ``urn:cite2:&lt;namespace&gt;:&lt;collection[.version]&gt;:&lt;object[-range]&gt;``.\n        \"\"\"\n        if not raw_string.startswith(\"urn:cite2:\"):\n            raise ValueError(\"CITE2 URN must start with 'urn:cite2:'\")\n\n        parts = raw_string.split(\":\")\n        if len(parts) != 5:\n            raise ValueError(\n                f\"CITE2 URN must have 5 colon-delimited parts, got {len(parts)} from {raw_string}.\"\n            )\n\n        header, urn_type, namespace, collection_info, object_info = parts\n\n        if header != \"urn\":\n            raise ValueError(\"CITE2 URN must start with 'urn'\")\n        if urn_type != \"cite2\":\n            raise ValueError(\"CITE2 URN must include the cite2 type identifier\")\n\n        if not namespace:\n            raise ValueError(\"Namespace component cannot be empty\")\n        if not collection_info:\n            raise ValueError(\"Collection info component cannot be empty\")\n        if not object_info:\n            raise ValueError(\"Object component cannot be empty\")\n\n        if collection_info.endswith(\".\"):\n            raise ValueError(\"Collection info cannot end with a period\")\n        collection_parts = collection_info.split(\".\")\n        if len(collection_parts) &gt; 2:\n            raise ValueError(\"Collection info can contain at most one period to separate collection and version\")\n        if any(part == \"\" for part in collection_parts):\n            raise ValueError(\"Collection info must contain non-empty collection/version values\")\n\n        collection = collection_parts[0]\n        version = collection_parts[1] if len(collection_parts) == 2 else None\n\n        if object_info.endswith(\"-\"):\n            raise ValueError(\"Object component cannot end with a hyphen\")\n        object_parts = object_info.split(\"-\")\n        if len(object_parts) &gt; 2:\n            raise ValueError(\"Object component can contain at most one hyphen to indicate a range\")\n        if any(part == \"\" for part in object_parts):\n            raise ValueError(\"Object component must contain non-empty identifiers\")\n\n        # Validate subreferences (at most one @ per range part, no empty subreferences)\n        for part in object_parts:\n            if part.count(\"@\") &gt; 1:\n                raise ValueError(f\"Each object component can have at most one @ delimiter for subreference, found {part.count('@')} in '{part}'\")\n            # Check for empty subreferences\n            if \"@\" in part:\n                subref_parts = part.split(\"@\")\n                if len(subref_parts) != 2 or not subref_parts[1]:\n                    raise ValueError(f\"Subreference cannot be empty, found empty subreference in '{part}'\")\n\n        object_id = object_info\n\n        return cls(\n            urn_type=urn_type,\n            namespace=namespace,\n            collection=collection,\n            version=version,\n            object_id=object_id,\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Serialize the Cite2Urn to its canonical string form.\"\"\"\n        collection_part = self.collection\n        if self.version is not None:\n            collection_part = f\"{collection_part}.{self.version}\"\n\n        object_part = self.object_id or \"\"\n\n        return f\"urn:{self.urn_type}:{self.namespace}:{collection_part}:{object_part}\"\n\n    def is_range(self) -&gt; bool:\n        \"\"\"Return True when the object component encodes a range (single hyphen).\"\"\"\n        if self.object_id is None:\n            return False\n\n        range_parts = self.object_id.split(\"-\")\n        return len(range_parts) == 2\n\n    def range_begin(self) -&gt; str | None:\n        \"\"\"Return the first identifier when the object component is a range.\"\"\"\n        if not self.is_range():\n            return None\n        return self.object_id.split(\"-\")[0]\n\n    def range_end(self) -&gt; str | None:\n        \"\"\"Return the second identifier when the object component is a range.\"\"\"\n        if not self.is_range():\n            return None\n        return self.object_id.split(\"-\")[1]\n\n    def has_subreference(self) -&gt; bool:\n        \"\"\"Check if the object identifier has a subreference.\n\n        An object identifier has a subreference if it contains at least one @ character,\n        which may appear on either or both parts of a range reference, or on\n        a single reference.\n\n        Returns:\n            bool: True if the object identifier contains a subreference (@ character), False otherwise.\n        \"\"\"\n        if self.object_id is None:\n            return False\n\n        return \"@\" in self.object_id\n\n    def has_subreference1(self) -&gt; bool:\n        \"\"\"Check if the range begin part has a subreference.\n\n        Returns True if the URN is a range and the range begin part contains\n        a @ character indicating a subreference.\n\n        Returns:\n            bool: True if the range begin part has a subreference, False otherwise.\n\n        Raises:\n            ValueError: If the URN is not a range.\n        \"\"\"\n        if not self.is_range():\n            raise ValueError(\"has_subreference1 can only be called on range URNs\")\n\n        range_begin = self.range_begin()\n        return \"@\" in range_begin if range_begin else False\n\n    def has_subreference2(self) -&gt; bool:\n        \"\"\"Check if the range end part has a subreference.\n\n        Returns True if the URN is a range and the range end part contains\n        a @ character indicating a subreference.\n\n        Returns:\n            bool: True if the range end part has a subreference, False otherwise.\n\n        Raises:\n            ValueError: If the URN is not a range.\n        \"\"\"\n        if not self.is_range():\n            raise ValueError(\"has_subreference2 can only be called on range URNs\")\n\n        range_end = self.range_end()\n        return \"@\" in range_end if range_end else False\n\n    def subreference(self) -&gt; str | None:\n        \"\"\"Get the subreference part of an object identifier.\n\n        Returns the subreference part (the text after @) if the object identifier has a subreference.\n        Returns None if the object identifier has no subreference.\n\n        Returns:\n            str | None: The subreference part, or None if no subreference exists.\n\n        Raises:\n            ValueError: If the URN is a range reference.\n        \"\"\"\n        if self.is_range():\n            raise ValueError(\"subreference can only be called on non-range URNs\")\n\n        if self.object_id is None or \"@\" not in self.object_id:\n            return None\n\n        parts = self.object_id.split(\"@\")\n        return parts[1]\n\n    def subreference1(self) -&gt; str | None:\n        \"\"\"Get the subreference part of the range begin reference.\n\n        Returns the subreference part (the text after @) of the range begin part\n        if it has a subreference. Returns None if the range begin part has no subreference.\n\n        Returns:\n            str | None: The subreference part of the range begin, or None if no subreference exists.\n\n        Raises:\n            ValueError: If the URN is not a range reference.\n        \"\"\"\n        if not self.is_range():\n            raise ValueError(\"subreference1 can only be called on range URNs\")\n\n        range_begin = self.range_begin()\n        if range_begin is None or \"@\" not in range_begin:\n            return None\n\n        parts = range_begin.split(\"@\")\n        return parts[1]\n\n    def subreference2(self) -&gt; str | None:\n        \"\"\"Get the subreference part of the range end reference.\n\n        Returns the subreference part (the text after @) of the range end part\n        if it has a subreference. Returns None if the range end part has no subreference.\n\n        Returns:\n            str | None: The subreference part of the range end, or None if no subreference exists.\n\n        Raises:\n            ValueError: If the URN is not a range reference.\n        \"\"\"\n        if not self.is_range():\n            raise ValueError(\"subreference2 can only be called on range URNs\")\n\n        range_end = self.range_end()\n        if range_end is None or \"@\" not in range_end:\n            return None\n\n        parts = range_end.split(\"@\")\n        return parts[1]\n\n    @classmethod\n    def valid_string(cls, raw_string: str) -&gt; bool:\n        \"\"\"Return True when the string can be parsed into a Cite2Urn.\"\"\"\n        try:\n            if not raw_string.startswith(\"urn:cite2:\"):\n                return False\n\n            parts = raw_string.split(\":\")\n            if len(parts) != 5:\n                return False\n\n            header, urn_type, namespace, collection_info, object_info = parts\n\n            if header != \"urn\" or urn_type != \"cite2\":\n                return False\n            if not namespace:\n                return False\n            if not collection_info or not object_info:\n                return False\n\n            # Collection rules: at most one period, not ending with a period, non-empty segments\n            if collection_info.endswith(\".\"):\n                return False\n            collection_parts = collection_info.split(\".\")\n            if len(collection_parts) &gt; 2:\n                return False\n            if any(part == \"\" for part in collection_parts):\n                return False\n\n            # Object rules: at most one hyphen, not ending with hyphen, non-empty segments\n            if object_info.endswith(\"-\"):\n                return False\n            object_parts = object_info.split(\"-\")\n            if len(object_parts) &gt; 2:\n                return False\n            if any(part == \"\" for part in object_parts):\n                return False\n\n            return True\n        except Exception:\n            return False\n    def collection_equals(self, other: \"Cite2Urn\") -&gt; bool:\n        \"\"\"Check if the collection hierarchy equals another Cite2Urn.\n\n        Compares the namespace, collection, and version fields.\n\n        Args:\n            other (Cite2Urn): The Cite2Urn to compare with.\n\n        Returns:\n            bool: True if all collection hierarchy fields are equal, False otherwise.\n        \"\"\"\n        return (\n            self.namespace == other.namespace\n            and self.collection == other.collection\n            and self.version == other.version\n        )\n\n    def collection_contains(self, other: \"Cite2Urn\") -&gt; bool:\n        \"\"\"Check if the collection hierarchy contains another Cite2Urn.\n\n        Returns True if all non-None values of namespace, collection, and version\n        in this Cite2Urn equal the corresponding values in the other Cite2Urn.\n\n        Args:\n            other (Cite2Urn): The Cite2Urn to compare with.\n\n        Returns:\n            bool: True if all non-None collection hierarchy fields match, False otherwise.\n        \"\"\"\n        if self.namespace is not None and self.namespace != other.namespace:\n            return False\n        if self.collection is not None and self.collection != other.collection:\n            return False\n        if self.version is not None and self.version != other.version:\n            return False\n        return True\n\n    def object_equals(self, other: \"Cite2Urn\") -&gt; bool:\n        \"\"\"Check if the object identifier equals another Cite2Urn.\n\n        Compares the object_id field of this Cite2Urn with the object_id field of another.\n\n        Args:\n            other (Cite2Urn): The Cite2Urn to compare with.\n\n        Returns:\n            bool: True if the object_id fields are equal, False otherwise.\n        \"\"\"\n        return self.object_id == other.object_id\n\n    def contains(self, other: Cite2Urn) -&gt; bool:\n        \"\"\"Check if this Cite2Urn contains another Cite2Urn.\n\n        Returns True if the collection hierarchy contains the other's collection hierarchy\n        AND the object identifiers are exactly equal.\n\n        Args:\n            other (Cite2Urn): The Cite2Urn to compare with.\n\n        Returns:\n            bool: True if collection_contains and object_equals are both True, False otherwise.\n        \"\"\"\n        return self.collection_contains(other) and self.object_equals(other)\n\n    def drop_version(self) -&gt; \"Cite2Urn\":\n        \"\"\"Create a new Cite2Urn without the version component.\n\n        Returns a new Cite2Urn instance with the same collection and object\n        but with the version set to None.\n\n        Returns:\n            Cite2Urn: A new Cite2Urn instance without the version component.\n        \"\"\"\n        return Cite2Urn(\n            urn_type=self.urn_type,\n            namespace=self.namespace,\n            collection=self.collection,\n            version=None,\n            object_id=self.object_id,\n        )\n\n    def drop_objectid(self) -&gt; \"Cite2Urn\":\n        \"\"\"Create a new Cite2Urn without the object_id component.\n\n        Returns a new Cite2Urn instance with the same collection hierarchy\n        but with the object_id set to None.\n\n        Returns:\n            Cite2Urn: A new Cite2Urn instance without the object_id component.\n        \"\"\"\n        return Cite2Urn(\n            urn_type=self.urn_type,\n            namespace=self.namespace,\n            collection=self.collection,\n            version=self.version,\n            object_id=None,\n        )\n\n    def drop_subreference(self) -&gt; \"Cite2Urn\":\n        \"\"\"Create a new Cite2Urn with all subreferences removed.\n\n        Returns a new Cite2Urn instance with subreferences (text after @) removed\n        from the object_id component. Works on both single objects and ranges.\n        If there are no subreferences, returns a new instance with the same object_id.\n\n        Returns:\n            Cite2Urn: A new Cite2Urn instance without subreferences in the object_id.\n        \"\"\"\n        if self.object_id is None or \"@\" not in self.object_id:\n            # No subreference to drop, return copy with same object_id\n            return Cite2Urn(\n                urn_type=self.urn_type,\n                namespace=self.namespace,\n                collection=self.collection,\n                version=self.version,\n                object_id=self.object_id,\n            )\n\n        # Remove subreferences from object_id\n        range_parts = self.object_id.split(\"-\")\n        cleaned_parts = []\n        for part in range_parts:\n            if \"@\" in part:\n                # Keep only the part before @\n                cleaned_parts.append(part.split(\"@\")[0])\n            else:\n                cleaned_parts.append(part)\n\n        new_object_id = \"-\".join(cleaned_parts)\n\n        return Cite2Urn(\n            urn_type=self.urn_type,\n            namespace=self.namespace,\n            collection=self.collection,\n            version=self.version,\n            object_id=new_object_id,\n        )\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.__str__","title":"<code>__str__()</code>","text":"<p>Serialize the Cite2Urn to its canonical string form.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Serialize the Cite2Urn to its canonical string form.\"\"\"\n    collection_part = self.collection\n    if self.version is not None:\n        collection_part = f\"{collection_part}.{self.version}\"\n\n    object_part = self.object_id or \"\"\n\n    return f\"urn:{self.urn_type}:{self.namespace}:{collection_part}:{object_part}\"\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.collection_contains","title":"<code>collection_contains(other)</code>","text":"<p>Check if the collection hierarchy contains another Cite2Urn.</p> <p>Returns True if all non-None values of namespace, collection, and version in this Cite2Urn equal the corresponding values in the other Cite2Urn.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Cite2Urn</code> <p>The Cite2Urn to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all non-None collection hierarchy fields match, False otherwise.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def collection_contains(self, other: \"Cite2Urn\") -&gt; bool:\n    \"\"\"Check if the collection hierarchy contains another Cite2Urn.\n\n    Returns True if all non-None values of namespace, collection, and version\n    in this Cite2Urn equal the corresponding values in the other Cite2Urn.\n\n    Args:\n        other (Cite2Urn): The Cite2Urn to compare with.\n\n    Returns:\n        bool: True if all non-None collection hierarchy fields match, False otherwise.\n    \"\"\"\n    if self.namespace is not None and self.namespace != other.namespace:\n        return False\n    if self.collection is not None and self.collection != other.collection:\n        return False\n    if self.version is not None and self.version != other.version:\n        return False\n    return True\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.collection_equals","title":"<code>collection_equals(other)</code>","text":"<p>Check if the collection hierarchy equals another Cite2Urn.</p> <p>Compares the namespace, collection, and version fields.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Cite2Urn</code> <p>The Cite2Urn to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all collection hierarchy fields are equal, False otherwise.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def collection_equals(self, other: \"Cite2Urn\") -&gt; bool:\n    \"\"\"Check if the collection hierarchy equals another Cite2Urn.\n\n    Compares the namespace, collection, and version fields.\n\n    Args:\n        other (Cite2Urn): The Cite2Urn to compare with.\n\n    Returns:\n        bool: True if all collection hierarchy fields are equal, False otherwise.\n    \"\"\"\n    return (\n        self.namespace == other.namespace\n        and self.collection == other.collection\n        and self.version == other.version\n    )\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.contains","title":"<code>contains(other)</code>","text":"<p>Check if this Cite2Urn contains another Cite2Urn.</p> <p>Returns True if the collection hierarchy contains the other's collection hierarchy AND the object identifiers are exactly equal.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Cite2Urn</code> <p>The Cite2Urn to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if collection_contains and object_equals are both True, False otherwise.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def contains(self, other: Cite2Urn) -&gt; bool:\n    \"\"\"Check if this Cite2Urn contains another Cite2Urn.\n\n    Returns True if the collection hierarchy contains the other's collection hierarchy\n    AND the object identifiers are exactly equal.\n\n    Args:\n        other (Cite2Urn): The Cite2Urn to compare with.\n\n    Returns:\n        bool: True if collection_contains and object_equals are both True, False otherwise.\n    \"\"\"\n    return self.collection_contains(other) and self.object_equals(other)\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.drop_objectid","title":"<code>drop_objectid()</code>","text":"<p>Create a new Cite2Urn without the object_id component.</p> <p>Returns a new Cite2Urn instance with the same collection hierarchy but with the object_id set to None.</p> <p>Returns:</p> Name Type Description <code>Cite2Urn</code> <code>Cite2Urn</code> <p>A new Cite2Urn instance without the object_id component.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def drop_objectid(self) -&gt; \"Cite2Urn\":\n    \"\"\"Create a new Cite2Urn without the object_id component.\n\n    Returns a new Cite2Urn instance with the same collection hierarchy\n    but with the object_id set to None.\n\n    Returns:\n        Cite2Urn: A new Cite2Urn instance without the object_id component.\n    \"\"\"\n    return Cite2Urn(\n        urn_type=self.urn_type,\n        namespace=self.namespace,\n        collection=self.collection,\n        version=self.version,\n        object_id=None,\n    )\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.drop_subreference","title":"<code>drop_subreference()</code>","text":"<p>Create a new Cite2Urn with all subreferences removed.</p> <p>Returns a new Cite2Urn instance with subreferences (text after @) removed from the object_id component. Works on both single objects and ranges. If there are no subreferences, returns a new instance with the same object_id.</p> <p>Returns:</p> Name Type Description <code>Cite2Urn</code> <code>Cite2Urn</code> <p>A new Cite2Urn instance without subreferences in the object_id.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def drop_subreference(self) -&gt; \"Cite2Urn\":\n    \"\"\"Create a new Cite2Urn with all subreferences removed.\n\n    Returns a new Cite2Urn instance with subreferences (text after @) removed\n    from the object_id component. Works on both single objects and ranges.\n    If there are no subreferences, returns a new instance with the same object_id.\n\n    Returns:\n        Cite2Urn: A new Cite2Urn instance without subreferences in the object_id.\n    \"\"\"\n    if self.object_id is None or \"@\" not in self.object_id:\n        # No subreference to drop, return copy with same object_id\n        return Cite2Urn(\n            urn_type=self.urn_type,\n            namespace=self.namespace,\n            collection=self.collection,\n            version=self.version,\n            object_id=self.object_id,\n        )\n\n    # Remove subreferences from object_id\n    range_parts = self.object_id.split(\"-\")\n    cleaned_parts = []\n    for part in range_parts:\n        if \"@\" in part:\n            # Keep only the part before @\n            cleaned_parts.append(part.split(\"@\")[0])\n        else:\n            cleaned_parts.append(part)\n\n    new_object_id = \"-\".join(cleaned_parts)\n\n    return Cite2Urn(\n        urn_type=self.urn_type,\n        namespace=self.namespace,\n        collection=self.collection,\n        version=self.version,\n        object_id=new_object_id,\n    )\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.drop_version","title":"<code>drop_version()</code>","text":"<p>Create a new Cite2Urn without the version component.</p> <p>Returns a new Cite2Urn instance with the same collection and object but with the version set to None.</p> <p>Returns:</p> Name Type Description <code>Cite2Urn</code> <code>Cite2Urn</code> <p>A new Cite2Urn instance without the version component.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def drop_version(self) -&gt; \"Cite2Urn\":\n    \"\"\"Create a new Cite2Urn without the version component.\n\n    Returns a new Cite2Urn instance with the same collection and object\n    but with the version set to None.\n\n    Returns:\n        Cite2Urn: A new Cite2Urn instance without the version component.\n    \"\"\"\n    return Cite2Urn(\n        urn_type=self.urn_type,\n        namespace=self.namespace,\n        collection=self.collection,\n        version=None,\n        object_id=self.object_id,\n    )\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.from_string","title":"<code>from_string(raw_string)</code>  <code>classmethod</code>","text":"<p>Parse a <code>urn:cite2</code> string into a <code>Cite2Urn</code> instance.</p> <p>The string must be in the form <code>urn:cite2:&lt;namespace&gt;:&lt;collection[.version]&gt;:&lt;object[-range]&gt;</code>.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>@classmethod\ndef from_string(cls, raw_string: str) -&gt; \"Cite2Urn\":\n    \"\"\"Parse a ``urn:cite2`` string into a ``Cite2Urn`` instance.\n\n    The string must be in the form ``urn:cite2:&lt;namespace&gt;:&lt;collection[.version]&gt;:&lt;object[-range]&gt;``.\n    \"\"\"\n    if not raw_string.startswith(\"urn:cite2:\"):\n        raise ValueError(\"CITE2 URN must start with 'urn:cite2:'\")\n\n    parts = raw_string.split(\":\")\n    if len(parts) != 5:\n        raise ValueError(\n            f\"CITE2 URN must have 5 colon-delimited parts, got {len(parts)} from {raw_string}.\"\n        )\n\n    header, urn_type, namespace, collection_info, object_info = parts\n\n    if header != \"urn\":\n        raise ValueError(\"CITE2 URN must start with 'urn'\")\n    if urn_type != \"cite2\":\n        raise ValueError(\"CITE2 URN must include the cite2 type identifier\")\n\n    if not namespace:\n        raise ValueError(\"Namespace component cannot be empty\")\n    if not collection_info:\n        raise ValueError(\"Collection info component cannot be empty\")\n    if not object_info:\n        raise ValueError(\"Object component cannot be empty\")\n\n    if collection_info.endswith(\".\"):\n        raise ValueError(\"Collection info cannot end with a period\")\n    collection_parts = collection_info.split(\".\")\n    if len(collection_parts) &gt; 2:\n        raise ValueError(\"Collection info can contain at most one period to separate collection and version\")\n    if any(part == \"\" for part in collection_parts):\n        raise ValueError(\"Collection info must contain non-empty collection/version values\")\n\n    collection = collection_parts[0]\n    version = collection_parts[1] if len(collection_parts) == 2 else None\n\n    if object_info.endswith(\"-\"):\n        raise ValueError(\"Object component cannot end with a hyphen\")\n    object_parts = object_info.split(\"-\")\n    if len(object_parts) &gt; 2:\n        raise ValueError(\"Object component can contain at most one hyphen to indicate a range\")\n    if any(part == \"\" for part in object_parts):\n        raise ValueError(\"Object component must contain non-empty identifiers\")\n\n    # Validate subreferences (at most one @ per range part, no empty subreferences)\n    for part in object_parts:\n        if part.count(\"@\") &gt; 1:\n            raise ValueError(f\"Each object component can have at most one @ delimiter for subreference, found {part.count('@')} in '{part}'\")\n        # Check for empty subreferences\n        if \"@\" in part:\n            subref_parts = part.split(\"@\")\n            if len(subref_parts) != 2 or not subref_parts[1]:\n                raise ValueError(f\"Subreference cannot be empty, found empty subreference in '{part}'\")\n\n    object_id = object_info\n\n    return cls(\n        urn_type=urn_type,\n        namespace=namespace,\n        collection=collection,\n        version=version,\n        object_id=object_id,\n    )\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.has_subreference","title":"<code>has_subreference()</code>","text":"<p>Check if the object identifier has a subreference.</p> <p>An object identifier has a subreference if it contains at least one @ character, which may appear on either or both parts of a range reference, or on a single reference.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the object identifier contains a subreference (@ character), False otherwise.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def has_subreference(self) -&gt; bool:\n    \"\"\"Check if the object identifier has a subreference.\n\n    An object identifier has a subreference if it contains at least one @ character,\n    which may appear on either or both parts of a range reference, or on\n    a single reference.\n\n    Returns:\n        bool: True if the object identifier contains a subreference (@ character), False otherwise.\n    \"\"\"\n    if self.object_id is None:\n        return False\n\n    return \"@\" in self.object_id\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.has_subreference1","title":"<code>has_subreference1()</code>","text":"<p>Check if the range begin part has a subreference.</p> <p>Returns True if the URN is a range and the range begin part contains a @ character indicating a subreference.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the range begin part has a subreference, False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URN is not a range.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def has_subreference1(self) -&gt; bool:\n    \"\"\"Check if the range begin part has a subreference.\n\n    Returns True if the URN is a range and the range begin part contains\n    a @ character indicating a subreference.\n\n    Returns:\n        bool: True if the range begin part has a subreference, False otherwise.\n\n    Raises:\n        ValueError: If the URN is not a range.\n    \"\"\"\n    if not self.is_range():\n        raise ValueError(\"has_subreference1 can only be called on range URNs\")\n\n    range_begin = self.range_begin()\n    return \"@\" in range_begin if range_begin else False\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.has_subreference2","title":"<code>has_subreference2()</code>","text":"<p>Check if the range end part has a subreference.</p> <p>Returns True if the URN is a range and the range end part contains a @ character indicating a subreference.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the range end part has a subreference, False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URN is not a range.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def has_subreference2(self) -&gt; bool:\n    \"\"\"Check if the range end part has a subreference.\n\n    Returns True if the URN is a range and the range end part contains\n    a @ character indicating a subreference.\n\n    Returns:\n        bool: True if the range end part has a subreference, False otherwise.\n\n    Raises:\n        ValueError: If the URN is not a range.\n    \"\"\"\n    if not self.is_range():\n        raise ValueError(\"has_subreference2 can only be called on range URNs\")\n\n    range_end = self.range_end()\n    return \"@\" in range_end if range_end else False\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.is_range","title":"<code>is_range()</code>","text":"<p>Return True when the object component encodes a range (single hyphen).</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def is_range(self) -&gt; bool:\n    \"\"\"Return True when the object component encodes a range (single hyphen).\"\"\"\n    if self.object_id is None:\n        return False\n\n    range_parts = self.object_id.split(\"-\")\n    return len(range_parts) == 2\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.object_equals","title":"<code>object_equals(other)</code>","text":"<p>Check if the object identifier equals another Cite2Urn.</p> <p>Compares the object_id field of this Cite2Urn with the object_id field of another.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Cite2Urn</code> <p>The Cite2Urn to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the object_id fields are equal, False otherwise.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def object_equals(self, other: \"Cite2Urn\") -&gt; bool:\n    \"\"\"Check if the object identifier equals another Cite2Urn.\n\n    Compares the object_id field of this Cite2Urn with the object_id field of another.\n\n    Args:\n        other (Cite2Urn): The Cite2Urn to compare with.\n\n    Returns:\n        bool: True if the object_id fields are equal, False otherwise.\n    \"\"\"\n    return self.object_id == other.object_id\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.range_begin","title":"<code>range_begin()</code>","text":"<p>Return the first identifier when the object component is a range.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def range_begin(self) -&gt; str | None:\n    \"\"\"Return the first identifier when the object component is a range.\"\"\"\n    if not self.is_range():\n        return None\n    return self.object_id.split(\"-\")[0]\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.range_end","title":"<code>range_end()</code>","text":"<p>Return the second identifier when the object component is a range.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def range_end(self) -&gt; str | None:\n    \"\"\"Return the second identifier when the object component is a range.\"\"\"\n    if not self.is_range():\n        return None\n    return self.object_id.split(\"-\")[1]\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.subreference","title":"<code>subreference()</code>","text":"<p>Get the subreference part of an object identifier.</p> <p>Returns the subreference part (the text after @) if the object identifier has a subreference. Returns None if the object identifier has no subreference.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The subreference part, or None if no subreference exists.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URN is a range reference.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def subreference(self) -&gt; str | None:\n    \"\"\"Get the subreference part of an object identifier.\n\n    Returns the subreference part (the text after @) if the object identifier has a subreference.\n    Returns None if the object identifier has no subreference.\n\n    Returns:\n        str | None: The subreference part, or None if no subreference exists.\n\n    Raises:\n        ValueError: If the URN is a range reference.\n    \"\"\"\n    if self.is_range():\n        raise ValueError(\"subreference can only be called on non-range URNs\")\n\n    if self.object_id is None or \"@\" not in self.object_id:\n        return None\n\n    parts = self.object_id.split(\"@\")\n    return parts[1]\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.subreference1","title":"<code>subreference1()</code>","text":"<p>Get the subreference part of the range begin reference.</p> <p>Returns the subreference part (the text after @) of the range begin part if it has a subreference. Returns None if the range begin part has no subreference.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The subreference part of the range begin, or None if no subreference exists.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URN is not a range reference.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def subreference1(self) -&gt; str | None:\n    \"\"\"Get the subreference part of the range begin reference.\n\n    Returns the subreference part (the text after @) of the range begin part\n    if it has a subreference. Returns None if the range begin part has no subreference.\n\n    Returns:\n        str | None: The subreference part of the range begin, or None if no subreference exists.\n\n    Raises:\n        ValueError: If the URN is not a range reference.\n    \"\"\"\n    if not self.is_range():\n        raise ValueError(\"subreference1 can only be called on range URNs\")\n\n    range_begin = self.range_begin()\n    if range_begin is None or \"@\" not in range_begin:\n        return None\n\n    parts = range_begin.split(\"@\")\n    return parts[1]\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.subreference2","title":"<code>subreference2()</code>","text":"<p>Get the subreference part of the range end reference.</p> <p>Returns the subreference part (the text after @) of the range end part if it has a subreference. Returns None if the range end part has no subreference.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The subreference part of the range end, or None if no subreference exists.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URN is not a range reference.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>def subreference2(self) -&gt; str | None:\n    \"\"\"Get the subreference part of the range end reference.\n\n    Returns the subreference part (the text after @) of the range end part\n    if it has a subreference. Returns None if the range end part has no subreference.\n\n    Returns:\n        str | None: The subreference part of the range end, or None if no subreference exists.\n\n    Raises:\n        ValueError: If the URN is not a range reference.\n    \"\"\"\n    if not self.is_range():\n        raise ValueError(\"subreference2 can only be called on range URNs\")\n\n    range_end = self.range_end()\n    if range_end is None or \"@\" not in range_end:\n        return None\n\n    parts = range_end.split(\"@\")\n    return parts[1]\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.valid_string","title":"<code>valid_string(raw_string)</code>  <code>classmethod</code>","text":"<p>Return True when the string can be parsed into a Cite2Urn.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>@classmethod\ndef valid_string(cls, raw_string: str) -&gt; bool:\n    \"\"\"Return True when the string can be parsed into a Cite2Urn.\"\"\"\n    try:\n        if not raw_string.startswith(\"urn:cite2:\"):\n            return False\n\n        parts = raw_string.split(\":\")\n        if len(parts) != 5:\n            return False\n\n        header, urn_type, namespace, collection_info, object_info = parts\n\n        if header != \"urn\" or urn_type != \"cite2\":\n            return False\n        if not namespace:\n            return False\n        if not collection_info or not object_info:\n            return False\n\n        # Collection rules: at most one period, not ending with a period, non-empty segments\n        if collection_info.endswith(\".\"):\n            return False\n        collection_parts = collection_info.split(\".\")\n        if len(collection_parts) &gt; 2:\n            return False\n        if any(part == \"\" for part in collection_parts):\n            return False\n\n        # Object rules: at most one hyphen, not ending with hyphen, non-empty segments\n        if object_info.endswith(\"-\"):\n            return False\n        object_parts = object_info.split(\"-\")\n        if len(object_parts) &gt; 2:\n            return False\n        if any(part == \"\" for part in object_parts):\n            return False\n\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"cite2urn/#urn_citation.Cite2Urn.validate_subreferences","title":"<code>validate_subreferences()</code>","text":"<p>Validate subreferences in object identifier.</p> <p>Ensures that: - object_id component has at most one @ per range part - subreferences are not empty</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the subreference constraints are violated.</p> Source code in <code>src/urn_citation/cite2urn.py</code> <pre><code>@model_validator(mode='after')\ndef validate_subreferences(self):\n    \"\"\"Validate subreferences in object identifier.\n\n    Ensures that:\n    - object_id component has at most one @ per range part\n    - subreferences are not empty\n\n    Raises:\n        ValueError: If the subreference constraints are violated.\n    \"\"\"\n    if self.object_id is not None:\n        range_parts = self.object_id.split(\"-\")\n        for part in range_parts:\n            if part.count(\"@\") &gt; 1:\n                raise ValueError(f\"Each object component can have at most one @ delimiter for subreference, found {part.count('@')} in '{part}'\")\n            # Check for empty subreferences\n            if \"@\" in part:\n                subref_parts = part.split(\"@\")\n                if len(subref_parts) != 2 or not subref_parts[1]:\n                    raise ValueError(f\"Subreference cannot be empty, found empty subreference in '{part}'\")\n\n    return self\n</code></pre>"},{"location":"ctsurn/","title":"Documentation for the <code>CtsUrn</code> class","text":""},{"location":"ctsurn/#urn_citation.CtsUrn","title":"<code>urn_citation.CtsUrn</code>","text":"<p>               Bases: <code>Urn</code></p> <p>A CTS URN identifying a passage of a canonically citable text.</p> <p>Canonical Text Service (CTS) URNs model passages of texts with two overlapping hierarchies: a work hierarchy, and a passage hierarchy. Values in the work hierarchy belong to a specified namespace. The work hierarchy is required to identify at least a text group; optionally, it may specify a work, a version (edition or translation) of the work, and exemplar (specific copy of the version). The passage hierarchy may be empty, in which case the URN refers to the entire contents of the work identified in the work hierarchy. Otherwise, the passage hierarchy identifies a specific passage of the work, at any depth of the citation hierarchy appropriate for the work (e.g., book, chapter, verse, line, token.) The passage hierarchy may identify either a single passage or a range of passages.</p> <p>Attributes:</p> Name Type Description <code>namespace</code> <code>str</code> <p>Required identifier for the namespace of the text (e.g., \"greekLit\" or \"latinLit\") where values for the work hierarchy are defined.</p> <code>text_group</code> <code>str</code> <p>Required identifier for text group.</p> <code>work</code> <code>str</code> <p>Optional identifier for work.</p> <code>version</code> <code>str</code> <p>Optional identifier for version (edition or translation) of the work.</p> <code>exemplar</code> <code>str</code> <p>Optional identifier for exemplar (specific copy of the version) of the work.</p> <code>passage</code> <code>str</code> <p>Optional identifier for passage of the work, at any depth of the citation hierarchy appropriate for the work (e.g., book, chapter, verse, line, token). May identify either a single passage or a range of passages.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>class CtsUrn(Urn):\n    \"\"\"A CTS URN identifying a passage of a canonically citable text.\n\n    Canonical Text Service (CTS) URNs model passages of texts with two overlapping hierarchies: a work hierarchy, and a passage hierarchy. Values in the work hierarchy belong to a specified namespace. The work hierarchy is required to identify at least a text group; optionally, it may specify a work, a version (edition or translation) of the work, and exemplar (specific copy of the version). The passage hierarchy may be empty, in which case the URN refers to the entire contents of the work identified in the work hierarchy. Otherwise, the passage hierarchy identifies a specific passage of the work, at any depth of the citation hierarchy appropriate for the work (e.g., book, chapter, verse, line, token.) The passage hierarchy may identify either a single passage or a range of passages.\n\n    Attributes:\n        namespace (str): Required identifier for the namespace of the text (e.g., \"greekLit\" or \"latinLit\") where values for the work hierarchy are defined.\n        text_group (str): Required identifier for text group.\n        work (str): Optional identifier for work.\n        version (str): Optional identifier for version (edition or translation) of the work.\n        exemplar (str): Optional identifier for exemplar (specific copy of the version) of the work.\n        passage (str): Optional identifier for passage of the work, at any depth of the citation hierarchy appropriate for the work (e.g., book, chapter, verse, line, token). May identify either a single passage or a range of passages.\n    \"\"\"    \n    namespace: str\n    text_group: str\n    work: str | None = None\n    version: str | None = None\n    exemplar: str | None = None\n    passage: str | None = None\n\n    @model_validator(mode='after')\n    def validate_work_hierarchy(self):\n        \"\"\"Validate the work hierarchy structure.\n\n        Ensures that:\n        - version cannot be set if work is None\n        - exemplar cannot be set if version or work is None\n        - passage component has at most one @ per range part\n\n        Raises:\n            ValueError: If the hierarchy constraints are violated.\n        \"\"\"\n        if self.version is not None and self.work is None:\n            raise ValueError(\"version cannot be set when work is None\")\n\n        # Check work before version for exemplar (check hierarchy from root to leaf)\n        if self.exemplar is not None and self.work is None:\n            raise ValueError(\"exemplar cannot be set when work is None\")\n\n        if self.exemplar is not None and self.version is None:\n            raise ValueError(\"exemplar cannot be set when version is None\")\n\n        # Validate subreferences in passage component\n        if self.passage is not None:\n            range_parts = self.passage.split(\"-\")\n            for part in range_parts:\n                if part.count(\"@\") &gt; 1:\n                    raise ValueError(f\"Each passage component can have at most one @ delimiter for subreference, found {part.count('@')} in '{part}'\")\n                # Check for empty subreferences\n                if \"@\" in part:\n                    subref_parts = part.split(\"@\")\n                    if len(subref_parts) != 2 or not subref_parts[1]:\n                        raise ValueError(f\"Subreference cannot be empty, found empty subreference in '{part}'\")\n\n        return self\n\n    @classmethod\n    def from_string(cls, raw_string):\n        # 1. Split the string into a list of values\n        parts = raw_string.split(\":\")\n        if len(parts) != 5:\n            raise ValueError(\"Bad.\")\n        header, urn_type, namespace, work_component, passage_component = parts\n\n        rangeparts = passage_component.split(\"-\")\n        if len(rangeparts) &gt; 2:\n            raise ValueError(f\"Passage component of CTS URN cannot have more than one hyphen to indicate a range, found {len(rangeparts)-1} hyphenated parts in {passage_component}.\")\n\n        # Validate subreferences (at most one @ per range part)\n        for part in rangeparts:\n            if part.count(\"@\") &gt; 1:\n                raise ValueError(f\"Each passage component can have at most one @ delimiter for subreference, found {part.count('@')} in '{part}'\")\n            # Check for empty subreferences\n            if \"@\" in part:\n                subref_parts = part.split(\"@\")\n                if len(subref_parts) != 2 or not subref_parts[1]:\n                    raise ValueError(f\"Subreference cannot be empty, found empty subreference in '{part}'\")\n\n        if \"..\" in work_component:\n            raise ValueError(f\"Work component of CTS URN cannot contain successive periods, found in {work_component}.\")\n\n        if \"..\" in passage_component:\n            raise ValueError(f\"Passage component of CTS URN cannot contain successive periods, found in {passage_component}.\")\n\n        workparts = work_component.split(\".\")\n        if len(workparts) &gt; 4:\n            raise ValueError(f\"Work component of CTS URN cannot have more than 4 dot-delimited components, got {len(workparts)} from {work_component}.\")\n\n        groupid, workid, versionid, exemplarid =         (workparts + [None] * 4)[:4]\n\n        if not passage_component:\n            passage_component = None\n\n        return cls(\n            urn_type=urn_type,\n            namespace=namespace,\n            text_group=groupid,\n            work=workid,\n            version=versionid,\n            exemplar=exemplarid,\n            passage=passage_component\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Serialize the CtsUrn to its string representation.\n\n        Returns a CTS URN string in the format:\n        urn:cts:namespace:work.hierarchy:passage\n\n        Where work.hierarchy is constructed from the text_group, work, version, and exemplar,\n        and passage is the passage component (or empty string if None).\n\n        Returns:\n            str: The serialized CTS URN string.\n        \"\"\"\n        # Build the work component from the work hierarchy\n        work_parts = [self.text_group]\n        if self.work is not None:\n            work_parts.append(self.work)\n        if self.version is not None:\n            work_parts.append(self.version)\n        if self.exemplar is not None:\n            work_parts.append(self.exemplar)\n\n        work_component = \".\".join(work_parts)\n\n        # Build the passage component (empty string if None)\n        passage_component = self.passage if self.passage is not None else \"\"\n\n        # Construct the full URN string\n        return f\"urn:{self.urn_type}:{self.namespace}:{work_component}:{passage_component}\"\n\n    def is_range(self) -&gt; bool:\n        \"\"\"Check if the passage component represents a range.\n\n        A passage is a range if it contains exactly one hyphen, indicating both\n        a range beginning and range end separated by that hyphen.\n\n        Returns:\n            bool: True if the passage is a range, False otherwise.\n        \"\"\"\n        if self.passage is None:\n            return False\n\n        range_parts = self.passage.split(\"-\")\n        return len(range_parts) == 2\n\n    def has_subreference(self) -&gt; bool:\n        \"\"\"Check if the passage component has a subreference.\n\n        A passage has a subreference if it contains at least one @ character,\n        which may appear on either or both parts of a range reference, or on\n        a single reference.\n\n        Returns:\n            bool: True if the passage contains a subreference (@ character), False otherwise.\n        \"\"\"\n        if self.passage is None:\n            return False\n\n        return \"@\" in self.passage\n\n    def has_subreference1(self) -&gt; bool:\n        \"\"\"Check if the range begin part has a subreference.\n\n        Returns True if the URN is a range and the range begin part contains\n        a @ character indicating a subreference.\n\n        Returns:\n            bool: True if the range begin part has a subreference, False otherwise.\n\n        Raises:\n            ValueError: If the URN is not a range.\n        \"\"\"\n        if not self.is_range():\n            raise ValueError(\"has_subreference1 can only be called on range URNs\")\n\n        range_begin = self.range_begin()\n        return \"@\" in range_begin if range_begin else False\n\n    def has_subreference2(self) -&gt; bool:\n        \"\"\"Check if the range end part has a subreference.\n\n        Returns True if the URN is a range and the range end part contains\n        a @ character indicating a subreference.\n\n        Returns:\n            bool: True if the range end part has a subreference, False otherwise.\n\n        Raises:\n            ValueError: If the URN is not a range.\n        \"\"\"\n        if not self.is_range():\n            raise ValueError(\"has_subreference2 can only be called on range URNs\")\n\n        range_end = self.range_end()\n        return \"@\" in range_end if range_end else False\n\n    def subreference(self) -&gt; str | None:\n        \"\"\"Get the subreference part of a passage reference.\n\n        Returns the subreference part (the text after @) if the passage has a subreference.\n        Returns None if the passage has no subreference.\n\n        Returns:\n            str | None: The subreference part, or None if no subreference exists.\n\n        Raises:\n            ValueError: If the URN is a range reference.\n        \"\"\"\n        if self.is_range():\n            raise ValueError(\"subreference can only be called on non-range URNs\")\n\n        if self.passage is None or \"@\" not in self.passage:\n            return None\n\n        parts = self.passage.split(\"@\")\n        return parts[1]\n\n    def subreference1(self) -&gt; str | None:\n        \"\"\"Get the subreference part of the range begin reference.\n\n        Returns the subreference part (the text after @) of the range begin part\n        if it has a subreference. Returns None if the range begin part has no subreference.\n\n        Returns:\n            str | None: The subreference part of the range begin, or None if no subreference exists.\n\n        Raises:\n            ValueError: If the URN is not a range reference.\n        \"\"\"\n        if not self.is_range():\n            raise ValueError(\"subreference1 can only be called on range URNs\")\n\n        range_begin = self.range_begin()\n        if range_begin is None or \"@\" not in range_begin:\n            return None\n\n        parts = range_begin.split(\"@\")\n        return parts[1]\n\n    def subreference2(self) -&gt; str | None:\n        \"\"\"Get the subreference part of the range end reference.\n\n        Returns the subreference part (the text after @) of the range end part\n        if it has a subreference. Returns None if the range end part has no subreference.\n\n        Returns:\n            str | None: The subreference part of the range end, or None if no subreference exists.\n\n        Raises:\n            ValueError: If the URN is not a range reference.\n        \"\"\"\n        if not self.is_range():\n            raise ValueError(\"subreference2 can only be called on range URNs\")\n\n        range_end = self.range_end()\n        if range_end is None or \"@\" not in range_end:\n            return None\n\n        parts = range_end.split(\"@\")\n        return parts[1]\n\n    def range_begin(self) -&gt; str | None:\n        \"\"\"Get the beginning of a passage range.\n\n        Returns the first range piece if the passage component represents a range\n        (i.e., contains exactly one hyphen). Returns None if the passage is not\n        a range or if passage is None.\n\n        Returns:\n            str | None: The beginning of the range, or None if not a range.\n        \"\"\"\n        if not self.is_range():\n            return None\n\n        range_parts = self.passage.split(\"-\")\n        return range_parts[0]\n\n    def range_end(self) -&gt; str | None:\n        \"\"\"Get the end of a passage range.\n\n        Returns the second range piece if the passage component represents a range\n        (i.e., contains exactly one hyphen). Returns None if the passage is not\n        a range or if passage is None.\n\n        Returns:\n            str | None: The end of the range, or None if not a range.\n        \"\"\"\n        if not self.is_range():\n            return None\n\n        range_parts = self.passage.split(\"-\")\n        return range_parts[1]\n\n    @classmethod\n    def valid_string(cls, raw_string: str) -&gt; bool:\n        \"\"\"Check if a string is valid for constructing a CtsUrn.\n\n        A valid CTS URN string must:\n        - Split into exactly 5 colon-delimited components\n        - Have a passage component with at most 1 hyphen (for ranges)\n        - Have a work component with at most 4 dot-delimited parts\n\n        Args:\n            raw_string (str): The string to validate.\n\n        Returns:\n            bool: True if the string is valid, False otherwise.\n        \"\"\"\n        try:\n            parts = raw_string.split(\":\")\n            if len(parts) != 5:\n                return False\n\n            header, urn_type, namespace, work_component, passage_component = parts\n\n            # Check passage component (at most 1 hyphen)\n            rangeparts = passage_component.split(\"-\")\n            if len(rangeparts) &gt; 2:\n                return False\n\n            # Check for successive periods in work and passage components\n            if \"..\" in work_component or \"..\" in passage_component:\n                return False\n\n            # Check work component (at most 4 dot-delimited parts)\n            workparts = work_component.split(\".\")\n            if len(workparts) &gt; 4:\n                return False\n\n            return True\n        except Exception:\n            return False\n\n    def work_equals(self, other: CtsUrn) -&gt; bool:\n        \"\"\"Check if the work hierarchy is equal to another CtsUrn.\n\n        Compares the text_group, work, version, and exemplar fields.\n\n        Args:\n            other (CtsUrn): The CtsUrn to compare with.\n\n        Returns:\n            bool: True if all work hierarchy fields are equal, False otherwise.\n        \"\"\"\n        return (\n            self.text_group == other.text_group\n            and self.work == other.work\n            and self.version == other.version\n            and self.exemplar == other.exemplar\n        )\n\n\n    # rewrite this using a more elegant `getattr` approach, and also add a docstring\n    def work_contains(self, other: CtsUrn) -&gt; bool:\n        \"\"\"Check if the work hierarchy contains another CtsUrn.\n\n        Returns True if all non-None values of text_group, work, version, and exemplar\n        in this CtsUrn equal the corresponding values in the other CtsUrn.\n\n        Args:\n            other (CtsUrn): The CtsUrn to compare with.\n\n        Returns:\n            bool: True if all non-None work hierarchy fields match, False otherwise.\n        \"\"\"\n        if self.text_group is not None and self.text_group != other.text_group:\n            return False\n        if self.work is not None and self.work != other.work:\n            return False\n        if self.version is not None and self.version != other.version:\n            return False\n        if self.exemplar is not None and self.exemplar != other.exemplar:\n            return False\n        return True\n\n    def passage_equals(self, other: CtsUrn) -&gt; bool:\n        \"\"\"Check if the passage component is equal to another CtsUrn.\n\n        Compares the passage field of this CtsUrn with the passage field of another.\n\n        Args:\n            other (CtsUrn): The CtsUrn to compare with.\n\n        Returns:\n            bool: True if the passage fields are equal, False otherwise.\n        \"\"\"\n        return self.passage == other.passage\n\n    def passage_contains(self, other: CtsUrn) -&gt; bool:\n        \"\"\"Check if the passage component contains another CtsUrn.\n\n        Returns True if:\n        - The passages are exactly equal, OR\n        - The other passage is at least 2 characters longer and starts with \n          this passage followed by a period character.\n\n        Raises ValueError if either passage is a range.\n\n        Examples:\n        - passage=\"1\", other.passage=\"1.11\" -&gt; True\n        - passage=\"1\", other.passage=\"12\" -&gt; False\n\n        Args:\n            other (CtsUrn): The CtsUrn to compare with.\n\n        Returns:\n            bool: True if the passages match the similarity criteria, False otherwise.\n\n        Raises:\n            ValueError: If either passage is a range (contains a hyphen).\n        \"\"\"\n        if self.is_range():\n            raise ValueError(\"passage_contains cannot be called on a CtsUrn with a range passage\")\n        if other.is_range():\n            raise ValueError(\"passage_contains cannot be called with a CtsUrn argument that has a range passage\")\n\n        # Check exact equality\n        if self.passage == other.passage:\n            return True\n\n        # Check if other passage is a refinement of this passage\n        if self.passage is not None and other.passage is not None:\n            expected_prefix = self.passage + \".\"\n            return (\n                len(other.passage) &gt;= len(self.passage) + 2\n                and other.passage.startswith(expected_prefix)\n            )\n\n        return False\n\n    def contains(self, other: CtsUrn) -&gt; bool:\n        \"\"\"Check if this CtsUrn contains another CtsUrn.\n\n        Returns True if both the work hierarchy and passage contain the other.\n\n        Args:\n            other (CtsUrn): The CtsUrn to compare with.\n\n        Returns:\n            bool: True if both work_contains and passage_contains are True, False otherwise.\n        \"\"\"\n        return self.work_contains(other) and self.passage_contains(other)\n\n    def drop_passage(self) -&gt; CtsUrn:\n        \"\"\"Create a new CtsUrn without the passage component.\n\n        Returns a new CtsUrn instance with the same work hierarchy but\n        with the passage set to None.\n\n        Returns:\n            CtsUrn: A new CtsUrn instance without the passage component.\n        \"\"\"\n        return CtsUrn(\n            urn_type=self.urn_type,\n            namespace=self.namespace,\n            text_group=self.text_group,\n            work=self.work,\n            version=self.version,\n            exemplar=self.exemplar,\n            passage=None\n        )\n\n    def set_passage(self, new_passage: str) -&gt; CtsUrn:\n        \"\"\"Create a new CtsUrn with a specified passage component.\n\n        Returns a new CtsUrn instance with the same work hierarchy but\n        with the passage set to the provided new_passage value.\n\n        Args:\n            new_passage (str | None): The new passage component to set.\n\n        Returns:\n            CtsUrn: A new CtsUrn instance with the updated passage component.\n        \"\"\"\n        return CtsUrn(\n            urn_type=self.urn_type,\n            namespace=self.namespace,\n            text_group=self.text_group,\n            work=self.work,\n            version=self.version,\n            exemplar=self.exemplar,\n            passage=new_passage\n        )\n\n\n    def drop_subreference(self) -&gt; CtsUrn:\n        \"\"\"Create a new CtsUrn with all subreferences removed.\n\n        Returns a new CtsUrn instance with subreferences (text after @) removed\n        from the passage component. Works on both single passages and ranges.\n        If there are no subreferences, returns a new instance with the same passage.\n\n        Returns:\n            CtsUrn: A new CtsUrn instance without subreferences in the passage.\n        \"\"\"\n        if self.passage is None or \"@\" not in self.passage:\n            # No subreference to drop, return copy with same passage\n            return CtsUrn(\n                urn_type=self.urn_type,\n                namespace=self.namespace,\n                text_group=self.text_group,\n                work=self.work,\n                version=self.version,\n                exemplar=self.exemplar,\n                passage=self.passage\n            )\n\n        # Remove subreferences from passage\n        range_parts = self.passage.split(\"-\")\n        cleaned_parts = []\n        for part in range_parts:\n            if \"@\" in part:\n                # Keep only the part before @\n                cleaned_parts.append(part.split(\"@\")[0])\n            else:\n                cleaned_parts.append(part)\n\n        new_passage = \"-\".join(cleaned_parts)\n\n        return CtsUrn(\n            urn_type=self.urn_type,\n            namespace=self.namespace,\n            text_group=self.text_group,\n            work=self.work,\n            version=self.version,\n            exemplar=self.exemplar,\n            passage=new_passage\n        )\n\n    def drop_version(self) -&gt; CtsUrn:\n        \"\"\"Create a new CtsUrn without the version component.\n\n        Returns a new CtsUrn instance with the same work hierarchy but\n        with the version set to None. Note: exemplar will also be set to None\n        since exemplar cannot exist without a version.\n\n        Returns:\n            CtsUrn: A new CtsUrn instance without the version component.\n        \"\"\"\n        return CtsUrn(\n            urn_type=self.urn_type,\n            namespace=self.namespace,\n            text_group=self.text_group,\n            work=self.work,\n            version=None,\n            exemplar=None,  # Must also drop exemplar since it requires version\n            passage=self.passage\n        )\n\n\n    def set_version(self, new_version: str) -&gt; CtsUrn:\n        \"\"\"Create a new CtsUrn with a specified version component.\n\n        Returns a new CtsUrn instance with the same work hierarchy but\n        with the version set to the provided new_version value.\n\n        Args:\n            new_version (str | None): The new version component to set.\n\n        Returns:\n            CtsUrn: A new CtsUrn instance with the updated version component.\n        \"\"\"\n        return CtsUrn(\n            urn_type=self.urn_type,\n            namespace=self.namespace,\n            text_group=self.text_group,\n            work=self.work,\n            version=new_version,\n            exemplar=self.exemplar,\n            passage=self.passage\n        )\n\n    def drop_exemplar(self) -&gt; CtsUrn:\n        \"\"\"Create a new CtsUrn without the exemplar component.\n\n        Returns a new CtsUrn instance with the same work hierarchy but\n        with the exemplar set to None.\n\n        Returns:\n            CtsUrn: A new CtsUrn instance without the exemplar component.\n        \"\"\"\n        return CtsUrn(\n            urn_type=self.urn_type,\n            namespace=self.namespace,\n            text_group=self.text_group,\n            work=self.work,\n            version=self.version,\n            exemplar=None,\n            passage=self.passage\n        )\n\n    def set_exemplar(self, new_exemplar: str) -&gt; CtsUrn:\n        \"\"\"Create a new CtsUrn with a specified exemplar component.\n\n        Returns a new CtsUrn instance with the same work hierarchy but\n        with the exemplar set to the provided new_exemplar value.\n\n        Args:\n            new_exemplar (str | None): The new exemplar component to set.\n\n        Returns:\n            CtsUrn: A new CtsUrn instance with the updated exemplar component.\n        \"\"\"\n        return CtsUrn(\n            urn_type=self.urn_type,\n            namespace=self.namespace,\n            text_group=self.text_group,\n            work=self.work,\n            version=self.version,\n            exemplar=new_exemplar,\n            passage=self.passage\n        )\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.__str__","title":"<code>__str__()</code>","text":"<p>Serialize the CtsUrn to its string representation.</p> <p>Returns a CTS URN string in the format: urn:cts:namespace:work.hierarchy:passage</p> <p>Where work.hierarchy is constructed from the text_group, work, version, and exemplar, and passage is the passage component (or empty string if None).</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The serialized CTS URN string.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Serialize the CtsUrn to its string representation.\n\n    Returns a CTS URN string in the format:\n    urn:cts:namespace:work.hierarchy:passage\n\n    Where work.hierarchy is constructed from the text_group, work, version, and exemplar,\n    and passage is the passage component (or empty string if None).\n\n    Returns:\n        str: The serialized CTS URN string.\n    \"\"\"\n    # Build the work component from the work hierarchy\n    work_parts = [self.text_group]\n    if self.work is not None:\n        work_parts.append(self.work)\n    if self.version is not None:\n        work_parts.append(self.version)\n    if self.exemplar is not None:\n        work_parts.append(self.exemplar)\n\n    work_component = \".\".join(work_parts)\n\n    # Build the passage component (empty string if None)\n    passage_component = self.passage if self.passage is not None else \"\"\n\n    # Construct the full URN string\n    return f\"urn:{self.urn_type}:{self.namespace}:{work_component}:{passage_component}\"\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.contains","title":"<code>contains(other)</code>","text":"<p>Check if this CtsUrn contains another CtsUrn.</p> <p>Returns True if both the work hierarchy and passage contain the other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>CtsUrn</code> <p>The CtsUrn to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if both work_contains and passage_contains are True, False otherwise.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def contains(self, other: CtsUrn) -&gt; bool:\n    \"\"\"Check if this CtsUrn contains another CtsUrn.\n\n    Returns True if both the work hierarchy and passage contain the other.\n\n    Args:\n        other (CtsUrn): The CtsUrn to compare with.\n\n    Returns:\n        bool: True if both work_contains and passage_contains are True, False otherwise.\n    \"\"\"\n    return self.work_contains(other) and self.passage_contains(other)\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.drop_exemplar","title":"<code>drop_exemplar()</code>","text":"<p>Create a new CtsUrn without the exemplar component.</p> <p>Returns a new CtsUrn instance with the same work hierarchy but with the exemplar set to None.</p> <p>Returns:</p> Name Type Description <code>CtsUrn</code> <code>CtsUrn</code> <p>A new CtsUrn instance without the exemplar component.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def drop_exemplar(self) -&gt; CtsUrn:\n    \"\"\"Create a new CtsUrn without the exemplar component.\n\n    Returns a new CtsUrn instance with the same work hierarchy but\n    with the exemplar set to None.\n\n    Returns:\n        CtsUrn: A new CtsUrn instance without the exemplar component.\n    \"\"\"\n    return CtsUrn(\n        urn_type=self.urn_type,\n        namespace=self.namespace,\n        text_group=self.text_group,\n        work=self.work,\n        version=self.version,\n        exemplar=None,\n        passage=self.passage\n    )\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.drop_passage","title":"<code>drop_passage()</code>","text":"<p>Create a new CtsUrn without the passage component.</p> <p>Returns a new CtsUrn instance with the same work hierarchy but with the passage set to None.</p> <p>Returns:</p> Name Type Description <code>CtsUrn</code> <code>CtsUrn</code> <p>A new CtsUrn instance without the passage component.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def drop_passage(self) -&gt; CtsUrn:\n    \"\"\"Create a new CtsUrn without the passage component.\n\n    Returns a new CtsUrn instance with the same work hierarchy but\n    with the passage set to None.\n\n    Returns:\n        CtsUrn: A new CtsUrn instance without the passage component.\n    \"\"\"\n    return CtsUrn(\n        urn_type=self.urn_type,\n        namespace=self.namespace,\n        text_group=self.text_group,\n        work=self.work,\n        version=self.version,\n        exemplar=self.exemplar,\n        passage=None\n    )\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.drop_subreference","title":"<code>drop_subreference()</code>","text":"<p>Create a new CtsUrn with all subreferences removed.</p> <p>Returns a new CtsUrn instance with subreferences (text after @) removed from the passage component. Works on both single passages and ranges. If there are no subreferences, returns a new instance with the same passage.</p> <p>Returns:</p> Name Type Description <code>CtsUrn</code> <code>CtsUrn</code> <p>A new CtsUrn instance without subreferences in the passage.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def drop_subreference(self) -&gt; CtsUrn:\n    \"\"\"Create a new CtsUrn with all subreferences removed.\n\n    Returns a new CtsUrn instance with subreferences (text after @) removed\n    from the passage component. Works on both single passages and ranges.\n    If there are no subreferences, returns a new instance with the same passage.\n\n    Returns:\n        CtsUrn: A new CtsUrn instance without subreferences in the passage.\n    \"\"\"\n    if self.passage is None or \"@\" not in self.passage:\n        # No subreference to drop, return copy with same passage\n        return CtsUrn(\n            urn_type=self.urn_type,\n            namespace=self.namespace,\n            text_group=self.text_group,\n            work=self.work,\n            version=self.version,\n            exemplar=self.exemplar,\n            passage=self.passage\n        )\n\n    # Remove subreferences from passage\n    range_parts = self.passage.split(\"-\")\n    cleaned_parts = []\n    for part in range_parts:\n        if \"@\" in part:\n            # Keep only the part before @\n            cleaned_parts.append(part.split(\"@\")[0])\n        else:\n            cleaned_parts.append(part)\n\n    new_passage = \"-\".join(cleaned_parts)\n\n    return CtsUrn(\n        urn_type=self.urn_type,\n        namespace=self.namespace,\n        text_group=self.text_group,\n        work=self.work,\n        version=self.version,\n        exemplar=self.exemplar,\n        passage=new_passage\n    )\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.drop_version","title":"<code>drop_version()</code>","text":"<p>Create a new CtsUrn without the version component.</p> <p>Returns a new CtsUrn instance with the same work hierarchy but with the version set to None. Note: exemplar will also be set to None since exemplar cannot exist without a version.</p> <p>Returns:</p> Name Type Description <code>CtsUrn</code> <code>CtsUrn</code> <p>A new CtsUrn instance without the version component.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def drop_version(self) -&gt; CtsUrn:\n    \"\"\"Create a new CtsUrn without the version component.\n\n    Returns a new CtsUrn instance with the same work hierarchy but\n    with the version set to None. Note: exemplar will also be set to None\n    since exemplar cannot exist without a version.\n\n    Returns:\n        CtsUrn: A new CtsUrn instance without the version component.\n    \"\"\"\n    return CtsUrn(\n        urn_type=self.urn_type,\n        namespace=self.namespace,\n        text_group=self.text_group,\n        work=self.work,\n        version=None,\n        exemplar=None,  # Must also drop exemplar since it requires version\n        passage=self.passage\n    )\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.has_subreference","title":"<code>has_subreference()</code>","text":"<p>Check if the passage component has a subreference.</p> <p>A passage has a subreference if it contains at least one @ character, which may appear on either or both parts of a range reference, or on a single reference.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the passage contains a subreference (@ character), False otherwise.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def has_subreference(self) -&gt; bool:\n    \"\"\"Check if the passage component has a subreference.\n\n    A passage has a subreference if it contains at least one @ character,\n    which may appear on either or both parts of a range reference, or on\n    a single reference.\n\n    Returns:\n        bool: True if the passage contains a subreference (@ character), False otherwise.\n    \"\"\"\n    if self.passage is None:\n        return False\n\n    return \"@\" in self.passage\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.has_subreference1","title":"<code>has_subreference1()</code>","text":"<p>Check if the range begin part has a subreference.</p> <p>Returns True if the URN is a range and the range begin part contains a @ character indicating a subreference.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the range begin part has a subreference, False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URN is not a range.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def has_subreference1(self) -&gt; bool:\n    \"\"\"Check if the range begin part has a subreference.\n\n    Returns True if the URN is a range and the range begin part contains\n    a @ character indicating a subreference.\n\n    Returns:\n        bool: True if the range begin part has a subreference, False otherwise.\n\n    Raises:\n        ValueError: If the URN is not a range.\n    \"\"\"\n    if not self.is_range():\n        raise ValueError(\"has_subreference1 can only be called on range URNs\")\n\n    range_begin = self.range_begin()\n    return \"@\" in range_begin if range_begin else False\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.has_subreference2","title":"<code>has_subreference2()</code>","text":"<p>Check if the range end part has a subreference.</p> <p>Returns True if the URN is a range and the range end part contains a @ character indicating a subreference.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the range end part has a subreference, False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URN is not a range.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def has_subreference2(self) -&gt; bool:\n    \"\"\"Check if the range end part has a subreference.\n\n    Returns True if the URN is a range and the range end part contains\n    a @ character indicating a subreference.\n\n    Returns:\n        bool: True if the range end part has a subreference, False otherwise.\n\n    Raises:\n        ValueError: If the URN is not a range.\n    \"\"\"\n    if not self.is_range():\n        raise ValueError(\"has_subreference2 can only be called on range URNs\")\n\n    range_end = self.range_end()\n    return \"@\" in range_end if range_end else False\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.is_range","title":"<code>is_range()</code>","text":"<p>Check if the passage component represents a range.</p> <p>A passage is a range if it contains exactly one hyphen, indicating both a range beginning and range end separated by that hyphen.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the passage is a range, False otherwise.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def is_range(self) -&gt; bool:\n    \"\"\"Check if the passage component represents a range.\n\n    A passage is a range if it contains exactly one hyphen, indicating both\n    a range beginning and range end separated by that hyphen.\n\n    Returns:\n        bool: True if the passage is a range, False otherwise.\n    \"\"\"\n    if self.passage is None:\n        return False\n\n    range_parts = self.passage.split(\"-\")\n    return len(range_parts) == 2\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.passage_contains","title":"<code>passage_contains(other)</code>","text":"<p>Check if the passage component contains another CtsUrn.</p> <p>Returns True if: - The passages are exactly equal, OR - The other passage is at least 2 characters longer and starts with    this passage followed by a period character.</p> <p>Raises ValueError if either passage is a range.</p> <p>Examples: - passage=\"1\", other.passage=\"1.11\" -&gt; True - passage=\"1\", other.passage=\"12\" -&gt; False</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>CtsUrn</code> <p>The CtsUrn to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the passages match the similarity criteria, False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either passage is a range (contains a hyphen).</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def passage_contains(self, other: CtsUrn) -&gt; bool:\n    \"\"\"Check if the passage component contains another CtsUrn.\n\n    Returns True if:\n    - The passages are exactly equal, OR\n    - The other passage is at least 2 characters longer and starts with \n      this passage followed by a period character.\n\n    Raises ValueError if either passage is a range.\n\n    Examples:\n    - passage=\"1\", other.passage=\"1.11\" -&gt; True\n    - passage=\"1\", other.passage=\"12\" -&gt; False\n\n    Args:\n        other (CtsUrn): The CtsUrn to compare with.\n\n    Returns:\n        bool: True if the passages match the similarity criteria, False otherwise.\n\n    Raises:\n        ValueError: If either passage is a range (contains a hyphen).\n    \"\"\"\n    if self.is_range():\n        raise ValueError(\"passage_contains cannot be called on a CtsUrn with a range passage\")\n    if other.is_range():\n        raise ValueError(\"passage_contains cannot be called with a CtsUrn argument that has a range passage\")\n\n    # Check exact equality\n    if self.passage == other.passage:\n        return True\n\n    # Check if other passage is a refinement of this passage\n    if self.passage is not None and other.passage is not None:\n        expected_prefix = self.passage + \".\"\n        return (\n            len(other.passage) &gt;= len(self.passage) + 2\n            and other.passage.startswith(expected_prefix)\n        )\n\n    return False\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.passage_equals","title":"<code>passage_equals(other)</code>","text":"<p>Check if the passage component is equal to another CtsUrn.</p> <p>Compares the passage field of this CtsUrn with the passage field of another.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>CtsUrn</code> <p>The CtsUrn to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the passage fields are equal, False otherwise.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def passage_equals(self, other: CtsUrn) -&gt; bool:\n    \"\"\"Check if the passage component is equal to another CtsUrn.\n\n    Compares the passage field of this CtsUrn with the passage field of another.\n\n    Args:\n        other (CtsUrn): The CtsUrn to compare with.\n\n    Returns:\n        bool: True if the passage fields are equal, False otherwise.\n    \"\"\"\n    return self.passage == other.passage\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.range_begin","title":"<code>range_begin()</code>","text":"<p>Get the beginning of a passage range.</p> <p>Returns the first range piece if the passage component represents a range (i.e., contains exactly one hyphen). Returns None if the passage is not a range or if passage is None.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The beginning of the range, or None if not a range.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def range_begin(self) -&gt; str | None:\n    \"\"\"Get the beginning of a passage range.\n\n    Returns the first range piece if the passage component represents a range\n    (i.e., contains exactly one hyphen). Returns None if the passage is not\n    a range or if passage is None.\n\n    Returns:\n        str | None: The beginning of the range, or None if not a range.\n    \"\"\"\n    if not self.is_range():\n        return None\n\n    range_parts = self.passage.split(\"-\")\n    return range_parts[0]\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.range_end","title":"<code>range_end()</code>","text":"<p>Get the end of a passage range.</p> <p>Returns the second range piece if the passage component represents a range (i.e., contains exactly one hyphen). Returns None if the passage is not a range or if passage is None.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The end of the range, or None if not a range.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def range_end(self) -&gt; str | None:\n    \"\"\"Get the end of a passage range.\n\n    Returns the second range piece if the passage component represents a range\n    (i.e., contains exactly one hyphen). Returns None if the passage is not\n    a range or if passage is None.\n\n    Returns:\n        str | None: The end of the range, or None if not a range.\n    \"\"\"\n    if not self.is_range():\n        return None\n\n    range_parts = self.passage.split(\"-\")\n    return range_parts[1]\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.set_exemplar","title":"<code>set_exemplar(new_exemplar)</code>","text":"<p>Create a new CtsUrn with a specified exemplar component.</p> <p>Returns a new CtsUrn instance with the same work hierarchy but with the exemplar set to the provided new_exemplar value.</p> <p>Parameters:</p> Name Type Description Default <code>new_exemplar</code> <code>str | None</code> <p>The new exemplar component to set.</p> required <p>Returns:</p> Name Type Description <code>CtsUrn</code> <code>CtsUrn</code> <p>A new CtsUrn instance with the updated exemplar component.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def set_exemplar(self, new_exemplar: str) -&gt; CtsUrn:\n    \"\"\"Create a new CtsUrn with a specified exemplar component.\n\n    Returns a new CtsUrn instance with the same work hierarchy but\n    with the exemplar set to the provided new_exemplar value.\n\n    Args:\n        new_exemplar (str | None): The new exemplar component to set.\n\n    Returns:\n        CtsUrn: A new CtsUrn instance with the updated exemplar component.\n    \"\"\"\n    return CtsUrn(\n        urn_type=self.urn_type,\n        namespace=self.namespace,\n        text_group=self.text_group,\n        work=self.work,\n        version=self.version,\n        exemplar=new_exemplar,\n        passage=self.passage\n    )\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.set_passage","title":"<code>set_passage(new_passage)</code>","text":"<p>Create a new CtsUrn with a specified passage component.</p> <p>Returns a new CtsUrn instance with the same work hierarchy but with the passage set to the provided new_passage value.</p> <p>Parameters:</p> Name Type Description Default <code>new_passage</code> <code>str | None</code> <p>The new passage component to set.</p> required <p>Returns:</p> Name Type Description <code>CtsUrn</code> <code>CtsUrn</code> <p>A new CtsUrn instance with the updated passage component.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def set_passage(self, new_passage: str) -&gt; CtsUrn:\n    \"\"\"Create a new CtsUrn with a specified passage component.\n\n    Returns a new CtsUrn instance with the same work hierarchy but\n    with the passage set to the provided new_passage value.\n\n    Args:\n        new_passage (str | None): The new passage component to set.\n\n    Returns:\n        CtsUrn: A new CtsUrn instance with the updated passage component.\n    \"\"\"\n    return CtsUrn(\n        urn_type=self.urn_type,\n        namespace=self.namespace,\n        text_group=self.text_group,\n        work=self.work,\n        version=self.version,\n        exemplar=self.exemplar,\n        passage=new_passage\n    )\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.set_version","title":"<code>set_version(new_version)</code>","text":"<p>Create a new CtsUrn with a specified version component.</p> <p>Returns a new CtsUrn instance with the same work hierarchy but with the version set to the provided new_version value.</p> <p>Parameters:</p> Name Type Description Default <code>new_version</code> <code>str | None</code> <p>The new version component to set.</p> required <p>Returns:</p> Name Type Description <code>CtsUrn</code> <code>CtsUrn</code> <p>A new CtsUrn instance with the updated version component.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def set_version(self, new_version: str) -&gt; CtsUrn:\n    \"\"\"Create a new CtsUrn with a specified version component.\n\n    Returns a new CtsUrn instance with the same work hierarchy but\n    with the version set to the provided new_version value.\n\n    Args:\n        new_version (str | None): The new version component to set.\n\n    Returns:\n        CtsUrn: A new CtsUrn instance with the updated version component.\n    \"\"\"\n    return CtsUrn(\n        urn_type=self.urn_type,\n        namespace=self.namespace,\n        text_group=self.text_group,\n        work=self.work,\n        version=new_version,\n        exemplar=self.exemplar,\n        passage=self.passage\n    )\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.subreference","title":"<code>subreference()</code>","text":"<p>Get the subreference part of a passage reference.</p> <p>Returns the subreference part (the text after @) if the passage has a subreference. Returns None if the passage has no subreference.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The subreference part, or None if no subreference exists.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URN is a range reference.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def subreference(self) -&gt; str | None:\n    \"\"\"Get the subreference part of a passage reference.\n\n    Returns the subreference part (the text after @) if the passage has a subreference.\n    Returns None if the passage has no subreference.\n\n    Returns:\n        str | None: The subreference part, or None if no subreference exists.\n\n    Raises:\n        ValueError: If the URN is a range reference.\n    \"\"\"\n    if self.is_range():\n        raise ValueError(\"subreference can only be called on non-range URNs\")\n\n    if self.passage is None or \"@\" not in self.passage:\n        return None\n\n    parts = self.passage.split(\"@\")\n    return parts[1]\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.subreference1","title":"<code>subreference1()</code>","text":"<p>Get the subreference part of the range begin reference.</p> <p>Returns the subreference part (the text after @) of the range begin part if it has a subreference. Returns None if the range begin part has no subreference.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The subreference part of the range begin, or None if no subreference exists.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URN is not a range reference.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def subreference1(self) -&gt; str | None:\n    \"\"\"Get the subreference part of the range begin reference.\n\n    Returns the subreference part (the text after @) of the range begin part\n    if it has a subreference. Returns None if the range begin part has no subreference.\n\n    Returns:\n        str | None: The subreference part of the range begin, or None if no subreference exists.\n\n    Raises:\n        ValueError: If the URN is not a range reference.\n    \"\"\"\n    if not self.is_range():\n        raise ValueError(\"subreference1 can only be called on range URNs\")\n\n    range_begin = self.range_begin()\n    if range_begin is None or \"@\" not in range_begin:\n        return None\n\n    parts = range_begin.split(\"@\")\n    return parts[1]\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.subreference2","title":"<code>subreference2()</code>","text":"<p>Get the subreference part of the range end reference.</p> <p>Returns the subreference part (the text after @) of the range end part if it has a subreference. Returns None if the range end part has no subreference.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The subreference part of the range end, or None if no subreference exists.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URN is not a range reference.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def subreference2(self) -&gt; str | None:\n    \"\"\"Get the subreference part of the range end reference.\n\n    Returns the subreference part (the text after @) of the range end part\n    if it has a subreference. Returns None if the range end part has no subreference.\n\n    Returns:\n        str | None: The subreference part of the range end, or None if no subreference exists.\n\n    Raises:\n        ValueError: If the URN is not a range reference.\n    \"\"\"\n    if not self.is_range():\n        raise ValueError(\"subreference2 can only be called on range URNs\")\n\n    range_end = self.range_end()\n    if range_end is None or \"@\" not in range_end:\n        return None\n\n    parts = range_end.split(\"@\")\n    return parts[1]\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.valid_string","title":"<code>valid_string(raw_string)</code>  <code>classmethod</code>","text":"<p>Check if a string is valid for constructing a CtsUrn.</p> <p>A valid CTS URN string must: - Split into exactly 5 colon-delimited components - Have a passage component with at most 1 hyphen (for ranges) - Have a work component with at most 4 dot-delimited parts</p> <p>Parameters:</p> Name Type Description Default <code>raw_string</code> <code>str</code> <p>The string to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the string is valid, False otherwise.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>@classmethod\ndef valid_string(cls, raw_string: str) -&gt; bool:\n    \"\"\"Check if a string is valid for constructing a CtsUrn.\n\n    A valid CTS URN string must:\n    - Split into exactly 5 colon-delimited components\n    - Have a passage component with at most 1 hyphen (for ranges)\n    - Have a work component with at most 4 dot-delimited parts\n\n    Args:\n        raw_string (str): The string to validate.\n\n    Returns:\n        bool: True if the string is valid, False otherwise.\n    \"\"\"\n    try:\n        parts = raw_string.split(\":\")\n        if len(parts) != 5:\n            return False\n\n        header, urn_type, namespace, work_component, passage_component = parts\n\n        # Check passage component (at most 1 hyphen)\n        rangeparts = passage_component.split(\"-\")\n        if len(rangeparts) &gt; 2:\n            return False\n\n        # Check for successive periods in work and passage components\n        if \"..\" in work_component or \"..\" in passage_component:\n            return False\n\n        # Check work component (at most 4 dot-delimited parts)\n        workparts = work_component.split(\".\")\n        if len(workparts) &gt; 4:\n            return False\n\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.validate_work_hierarchy","title":"<code>validate_work_hierarchy()</code>","text":"<p>Validate the work hierarchy structure.</p> <p>Ensures that: - version cannot be set if work is None - exemplar cannot be set if version or work is None - passage component has at most one @ per range part</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the hierarchy constraints are violated.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>@model_validator(mode='after')\ndef validate_work_hierarchy(self):\n    \"\"\"Validate the work hierarchy structure.\n\n    Ensures that:\n    - version cannot be set if work is None\n    - exemplar cannot be set if version or work is None\n    - passage component has at most one @ per range part\n\n    Raises:\n        ValueError: If the hierarchy constraints are violated.\n    \"\"\"\n    if self.version is not None and self.work is None:\n        raise ValueError(\"version cannot be set when work is None\")\n\n    # Check work before version for exemplar (check hierarchy from root to leaf)\n    if self.exemplar is not None and self.work is None:\n        raise ValueError(\"exemplar cannot be set when work is None\")\n\n    if self.exemplar is not None and self.version is None:\n        raise ValueError(\"exemplar cannot be set when version is None\")\n\n    # Validate subreferences in passage component\n    if self.passage is not None:\n        range_parts = self.passage.split(\"-\")\n        for part in range_parts:\n            if part.count(\"@\") &gt; 1:\n                raise ValueError(f\"Each passage component can have at most one @ delimiter for subreference, found {part.count('@')} in '{part}'\")\n            # Check for empty subreferences\n            if \"@\" in part:\n                subref_parts = part.split(\"@\")\n                if len(subref_parts) != 2 or not subref_parts[1]:\n                    raise ValueError(f\"Subreference cannot be empty, found empty subreference in '{part}'\")\n\n    return self\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.work_contains","title":"<code>work_contains(other)</code>","text":"<p>Check if the work hierarchy contains another CtsUrn.</p> <p>Returns True if all non-None values of text_group, work, version, and exemplar in this CtsUrn equal the corresponding values in the other CtsUrn.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>CtsUrn</code> <p>The CtsUrn to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all non-None work hierarchy fields match, False otherwise.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def work_contains(self, other: CtsUrn) -&gt; bool:\n    \"\"\"Check if the work hierarchy contains another CtsUrn.\n\n    Returns True if all non-None values of text_group, work, version, and exemplar\n    in this CtsUrn equal the corresponding values in the other CtsUrn.\n\n    Args:\n        other (CtsUrn): The CtsUrn to compare with.\n\n    Returns:\n        bool: True if all non-None work hierarchy fields match, False otherwise.\n    \"\"\"\n    if self.text_group is not None and self.text_group != other.text_group:\n        return False\n    if self.work is not None and self.work != other.work:\n        return False\n    if self.version is not None and self.version != other.version:\n        return False\n    if self.exemplar is not None and self.exemplar != other.exemplar:\n        return False\n    return True\n</code></pre>"},{"location":"ctsurn/#urn_citation.CtsUrn.work_equals","title":"<code>work_equals(other)</code>","text":"<p>Check if the work hierarchy is equal to another CtsUrn.</p> <p>Compares the text_group, work, version, and exemplar fields.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>CtsUrn</code> <p>The CtsUrn to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all work hierarchy fields are equal, False otherwise.</p> Source code in <code>src/urn_citation/ctsurn.py</code> <pre><code>def work_equals(self, other: CtsUrn) -&gt; bool:\n    \"\"\"Check if the work hierarchy is equal to another CtsUrn.\n\n    Compares the text_group, work, version, and exemplar fields.\n\n    Args:\n        other (CtsUrn): The CtsUrn to compare with.\n\n    Returns:\n        bool: True if all work hierarchy fields are equal, False otherwise.\n    \"\"\"\n    return (\n        self.text_group == other.text_group\n        and self.work == other.work\n        and self.version == other.version\n        and self.exemplar == other.exemplar\n    )\n</code></pre>"},{"location":"reference/","title":"API documentation","text":"<p>The base class for the <code>urn_citation</code> package is <code>Urn</code>, with two subclasses: <code>CtsUrn</code> for CTS URNs and <code>Cite2Urn</code> for CITE2 URNs.</p>"},{"location":"reference/#urn_citation.Urn","title":"<code>urn_citation.Urn</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Superclass for URN types.</p> <p>All URNs are required to have a type identifier.</p> <p>Attributes:</p> Name Type Description <code>urn_type</code> <code>str</code> <p>Required identifier for URN type.</p> Source code in <code>src/urn_citation/urn.py</code> <pre><code>class Urn(BaseModel):\n    \"\"\"Superclass for URN types.\n\n    All URNs are required to have a type identifier.\n\n    Attributes:\n        urn_type (str): Required identifier for URN type.\n\n    \"\"\"    \n    urn_type: str\n</code></pre>"},{"location":"reference/#the-subclasses","title":"The subclasses","text":"<ul> <li>CtsUrn</li> <li>Cite2Urn</li> </ul>"}]}